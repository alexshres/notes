# Jan. 18 2026

Reviewed LeetCode Two-Pointer strategy: 
1. Bidirectional pointers: usually want sorted array for this but the maximum height based on bars seems to work for this so idk.
    * left=0 and right=n-1
    * evaluate left and right
    * move left if we need a larger value
    * move right if need a smaller value
2. Fast and slow pointer (arrays): This one I thought I had but am still struggling with. There seem to be multiple variants of this:
    * we can have different ranges: `range(len(nums))` or `range(1, len(nums))` or `range(k, len(nums))` which are all interesting
    * one of the main things to think about is when do we "write" using the slow pointer?
    * for removing duplicates we start at `range(1, len(nums))` given that array is sorted and for removing values we start at the 0th index
    * fast pointer moves forward at every step (can think of this as the "read" pointer) and slow pointer only moves when a condition has been met (at which point we write over the value thus the "write" pointer)
    * common for the loop body to have something of the form:
        ```python

        for i in range(k, len(nums)):
            if nums[fast] meets condition:  # if nums[fast] != nums[slow]
                slow += 1                   # slow update can be here
                nums[slow] = nums[fast]
                slow += 1                   # or slow update can be here
        ```

Also looked into PyTorch `gather` function yesterday. Basically the way gather seems to work is:

```python
# output specified by a 3D Tensor
# index MUST have the same number of dimensions as input
# output will have the same size as index

dim = 0
output[i, j, k] = input[index[i, j, k], j, k]

dim = 1
output[i, j, k] = input[i, index[i, j, k], k]

dim=2
output[i, j, k] = input[i, j, index[i, j, k]]

```

